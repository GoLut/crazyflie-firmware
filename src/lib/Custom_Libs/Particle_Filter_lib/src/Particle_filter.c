//particle filter libraries
#include "Particle_filter.h"
#include "gen_norm.h"

//C libraries
#include <stdbool.h>
#include <stdlib.h>
#include <math.h>
//crazyflie libraries
#include "debug.h"

//free RTOS
#include "FreeRTOS.h"
#include "task.h"

//IMU sensors:
#include "sensors.h"


#define MAP_CELL_SIZE 0.75
#define LENS_FOCAL_LENGTH 9

#define PARTICLE_CORRECT_COLOR_PROBABILITY 80
#define PARTICLE_WRONG_COLOR_PROBABILITY 20

#define PARTICLE_FILTER_MAX_MAP_SIZE 127 //cm  8 x 0.75 cm  = 127.333 -> 127
#define PARTICLE_FILTER_STARTING_Z 200//cm

#define UPDATE_ALL_PARTICLES_AFTER_MOTION_MODEL_STEPS 200 
#define UPDATE_TIME_INTERVAL_PARTICLE_RESAMPLE 10000 //ms

#define MAX_VELOCITY_BEFORE_RESET_FILTER 0.4f



bool particle_filter_inited = false;

//acceleration data from IMU
float a_x = 0.0f;
float a_y = 0.0f;
float a_z = 0.0f;

//motion model particle
MotionModelParticle motion_model_particle;

Particle particles[PARTICLE_FILTER_NUM_OF_PARTICLES];

//the map initialize the map (use python script for this)
//TODO make python script for this later to export the map generated by the map algorithm
// const uint8_t COLOR_MAP[MAP_SIZE][MAP_SIZE] ={
//     {0,10,20,30,40,50,60,70,80,90},
//     {1,11,21,31,41,51,61,71,81,91},
//     {2,12,22,32,42,52,62,72,82,92},
//     {3,13,23,33,43,53,63,73,83,93},
//     {4,14,24,34,44,54,64,74,84,94},
//     {5,15,25,35,45,55,65,75,85,95},
//     {6,16,26,36,46,56,66,76,86,96},
//     {7,17,27,37,47,57,67,77,87,97},
//     {8,18,28,38,48,58,68,78,88,98},
//     {9,19,29,39,49,59,69,79,89,99}
//     }; 

const uint8_t COLOR_MAP[MAP_SIZE][MAP_SIZE] ={
{0, 1, 3, 1, 2, 1, 5, 1},
{2, 5, 6, 5, 0, 3, 6, 2},
{4, 3, 1, 4, 2, 1, 0, 3},
{6, 2, 6, 3, 6, 3, 5, 2},
{1, 3, 4, 2, 5, 2, 1, 6},
{0, 6, 5, 1, 0, 4, 3, 2},
{4, 3, 0, 6, 2, 5, 0, 4},
{0, 5, 1, 5, 3, 1, 3, 2},
};


void DEBUG_PARTICLE(Particle* p, int i){
    DEBUG_PRINT("P%d: Pc: %.2f, %.2f, %.2f, Pn: %.2f, %.2f, %.2f, P: %u, C: %u\n",
    i, (double)p->x_curr, (double)p->y_curr, (double)p->z_curr, 
    (double)p->x_new, (double)p->y_new, (double)p->z_new, 
    p->prob, p->expected_color);
}

void DEBUG_MOTION_PARTICLE(MotionModelParticle* p){
    // DEBUG_PRINT("test\n");
    DEBUG_PRINT("\nMMP: a: %.5f, %.5f, %.5f, v: %.5f, %.5f, %.5f, \n p: %.5f, %.5f, %.5f, pa: %.5f, %.5f, %.5f, s:%u \n",
    (double)p->a_x, (double)p->a_y, (double)p->a_z, 
    (double)p->v_x, (double)p->v_y, (double)p->v_z, 
    (double)p->x_curr, (double)p->y_curr, (double)p->z_curr, 
    (double)p->x_abs, (double)p->y_abs, (double)p->z_abs, 
    p->motion_model_step_counter);
}

//uniform_distribution returns an INTEGER in [rangeLow, rangeHigh], inclusive.*/
//https://stackoverflow.com/questions/11641629/generating-a-uniform-distribution-of-integers-in-c
int32_t uniform_distribution(int32_t rangeLow, int32_t rangeHigh) {
    double myRand = rand()/(1.0 + RAND_MAX); 
    int32_t range = rangeHigh - rangeLow + 1;
    int32_t myRand_scaled = (myRand * range) + rangeLow;
    return myRand_scaled;
}

/**
 * @brief exponental weigther moving average filter
 * 
 * @param n new measurement
 * @param alpha scaling factor
 * @param n_1 last calculated ewma value
 * @return float new ewma value
 */
float EWMA(float n, float alpha, float n_1){
    return ((alpha*n) + ((1.0f - alpha) * n_1));
}

/**
 * @brief Call during the init, will take samples to calibrate the IMU ofset
 * A EWMA is used to do the calibration.
 * TODO might not be nessesary because the PID controller on the drone will attempt to set the acc to 0;
 *      we have to test.
 * 
 * @param p motion model particle
 */
void calibrate_motion_model_IMU_on_startup(){
    // const TickType_t xDelay = 100 / portTICK_PERIOD_MS;  

    if (logGetUint(motion_model_particle.syscanfly)){
        // DEBUG_PRINT("can fly");
        if(!motion_model_particle.calibrated){
            float x_n = logGetFloat(motion_model_particle.id_acc_x);
            float y_n = logGetFloat(motion_model_particle.id_acc_y);
            float z_n = logGetFloat(motion_model_particle.id_acc_z);

            //calculate exponential weighted moving average
            motion_model_particle.a_x_cali = EWMA(x_n, motion_model_particle.alpha, motion_model_particle.a_x_cali);
            motion_model_particle.a_y_cali = EWMA(y_n, motion_model_particle.alpha, motion_model_particle.a_y_cali);
            motion_model_particle.a_z_cali = EWMA(z_n, motion_model_particle.alpha, motion_model_particle.a_z_cali);

            //increment counter we would like to take a large amount of samples
            motion_model_particle.EWMA_counter += 1;

            //set calibration to true when we are done.
            if(motion_model_particle.EWMA_counter >= motion_model_particle.EWMA_number_of_calibration_measurements){
                motion_model_particle.calibrated = true;
            }
            // DEBUG_PRINT("NOT calibrated %d \n", motion_model_particle.EWMA_counter );
        }
        else{
            DEBUG_PRINT("calibrated\n");
        }
    }
}

bool particle_filter_is_calibrated(){
    return motion_model_particle.calibrated;
}


//sets the initial uniform distribution of particle location
void set_initial_uniform_particle_distribution(Particle * p){
//generate x and y location from uniform distribution
    p->x_curr = (float)uniform_distribution(0,PARTICLE_FILTER_MAX_MAP_SIZE);
    p->y_curr = (float)uniform_distribution(0,PARTICLE_FILTER_MAX_MAP_SIZE);

    // DEBUG_PRINT("px, py, %f, %f \n", (double)p->x_curr, (double)p->y_curr);
    
    //set the z to be a fixed distance for now
    p->z_curr = PARTICLE_FILTER_STARTING_Z;
    //new location equals current locations.
    p->x_new = p->x_curr;
    p->y_new = p->y_curr;
    p->z_new = p->z_curr;
}

//set the particle probability to be all on the false color.
void set_particle_initial_probability(Particle * p){
    p->prob = PARTICLE_WRONG_COLOR_PROBABILITY;
}

// Calculates the estimated Cell size based on distance estimate of the particle X following a linar expanding formula
// https://www.notion.so/Week-20-21-5d91501fcd6844448b9e00b5bad383fa?pvs=4#d4aa3bc2a5624236b2a0bd661e46bb4a
void calc_cell_size_at_particle_distance(Particle * p, float* cell_size){
    //formula for the cell size over distance is linear
    *cell_size = ((p->z_curr - (float)LENS_FOCAL_LENGTH)/ (float)LENS_FOCAL_LENGTH) * (float)MAP_CELL_SIZE;
    // DEBUG_PRINT("Cell size: %f\n ", (double)*cell_size);
}


// Look up Table of the color projection map. 
// Returns  - the expected color based on the particle X and Y cell location.
//          - Number of Colors if not valid ID is found. 
uint8_t color_map_LUT(int16_t x, int16_t y){
    //Boundary check if we are inside the map projection
    if((x>=0) && (x< MAP_SIZE) && (y >= 0) && (y < MAP_SIZE)){
        //If inside the boundary we would like to return the color
        return COLOR_MAP[y][x];  
    }
    // return ambient ID (we are outside of the map.)
    return NUMBER_OF_COLORS; 
}

//Returns the particle color based on its 
// - Position in space
// - The estimated Cell size at its estimated distance from the projection source.
void find_map_color_for_particle(Particle * p, float* cell_size){
    //map drone P_x and P_y to the CELL. x,y positions by scaling with the cell size
    int16_t map_x = (int16_t)floorf(p->x_curr/ *cell_size);
    int16_t map_y = (int16_t)floorf(p->y_curr/ *cell_size);
    // DEBUG_PRINT("x,y: %d, %d",map_x, map_y );
    //Lookup the expected color based on the known map
    p->expected_color = color_map_LUT(map_x, map_y);
}

//This function updates the expected to be recieving color for all particles based on their:
// - X, Y, Z position in space.
// We do this process of updating colors in 3 steps.
    // 1. Caluclate the expected cell size based on z distance and linear projection expanding formula.
    // 2. Map the drone x, y pose to the x,y positions of all cells.
    // 3. Find the expected to be recieving color from the Look up table and update the particle state.
void determine_expected_color_for_all_particles(){
    for (uint32_t i = 0; i < PARTICLE_FILTER_NUM_OF_PARTICLES; i++)
    {
        float cell_size = 0;
        calc_cell_size_at_particle_distance(&particles[i], &cell_size);
        find_map_color_for_particle(&particles[i], &cell_size);
        // DEBUG_PARTICLE(&particles[i]);
    }
}

//Update the particle probability based on the expected color and the recieved color by the color sensor
//The probability of a particle recieving the correct color is set to a higher value.
//The probability of a particle receiving the wrong color is set to a lower value.
//returns the number of particles with a wrong color
int set_particle_probability(uint16_t last_recieved_color){
    uint16_t number_of_particles_with_wrong_color = 0;
    for (uint32_t i = 0; i < PARTICLE_FILTER_NUM_OF_PARTICLES; i++)
    {
        if((uint16_t)particles[i].expected_color == last_recieved_color){
            particles[i].prob = PARTICLE_CORRECT_COLOR_PROBABILITY;
        }else{
            particles[i].prob = PARTICLE_WRONG_COLOR_PROBABILITY;
            number_of_particles_with_wrong_color++;
        }
        // DEBUG_PARTICLE(&particles[i]);
    }  
    return number_of_particles_with_wrong_color;
}

//Set a particle 2 new_location to the current_location of particle 1. (Don't move the particles yet.)
void set_new_xyz_position(Particle * p1, Particle * p2){
    //assign new location to the particle
    p2->x_new = p1->x_curr;
    p2->y_new = p1->y_curr;
    p2->z_new = p1->z_curr;
}

//itterate over all particles:
//update a particles location to the new location (Resampling and actually moving the particle)
void place_particles_on_new_location(){
    Particle *p;
    
    // DEBUG_PRINT("Resampling done placing particles at new pose:\n");

    for (uint32_t i = 0; i < PARTICLE_FILTER_NUM_OF_PARTICLES; i++){
        //update the position
        p = &particles[i];
        p->x_curr = p->x_new;
        p->y_curr = p->y_new;
        p->z_curr = p->z_new;
        // DEBUG_PARTICLE(p);
    }
}

/*this function syncs the current particle location with the shortend 16 style particle location*/
void sync_int16_particle_locations(){
    Particle *p;
    for (uint32_t i = 0; i < PARTICLE_FILTER_NUM_OF_PARTICLES; i++){
        //update the position
        p = &particles[i];

        p->x_curr_16 = (int16_t)p->x_curr;
        p->y_curr_16 = (int16_t)p->y_curr;
    }
}

void calculate_mean_particle_location(MotionModelParticle* mp){
    mp->x_mean = 0.0f;
    mp->y_mean = 0.0f;
    mp->z_mean = 0.0f;
    
    Particle * p;
    for (uint32_t i = 0; i < PARTICLE_FILTER_NUM_OF_PARTICLES; i++){
        //update the position
        p = &particles[i];
        mp->x_mean += p->x_curr;
        mp->y_mean += p->y_curr;
        mp->z_mean += p->z_curr;
    }
    //calculate the average.
    mp->x_mean = mp->x_mean/(float)PARTICLE_FILTER_NUM_OF_PARTICLES;
    mp->y_mean = mp->y_mean/(float)PARTICLE_FILTER_NUM_OF_PARTICLES;
    mp->z_mean = mp->z_mean/(float)PARTICLE_FILTER_NUM_OF_PARTICLES;
}

/**
 * Resample all particles acording to the new probability distribution
 * How does the resampling based on probability work:
 * 
 * We have i particle that require a new probability
 * addition we have a local probability counter.
 * Steps: 
 *      1. We keep itterating over the list of particles (j) looking at the probability property of the particles. (loop back to 0 when at end of list)
 *      2. From this p_counter we substract the probability property of every particle.
 *      3. When probability counter <= 0 then we assign the ith particle to the location of the jth particle saving the overflow for the next particle
 *      //NOTE that the particles will resample to the higher probability more often over the lower probability.
 * */
void resample_particles(){
    //probability counter
    int16_t p_counter = uniform_distribution(50,200);
    //this ways we use all the particles instead of only the first few
    uint32_t j = uniform_distribution(0,(PARTICLE_FILTER_NUM_OF_PARTICLES-1));
    // DEBUG_PRINT("starting J and P: %lu,  %d\n", j ,p_counter);

    uint16_t overflow = 0;

    for (uint32_t i = 0; i < PARTICLE_FILTER_NUM_OF_PARTICLES; i++)
    {
        //substract overflow from previous particle.
        p_counter = p_counter - overflow;

        while (p_counter > 0){
            p_counter = p_counter - particles[j].prob;
            //only increment j if there is p left.
            if (p_counter >= 0){
                // //pick a random J
                // j = uniform_distribution(0,(PARTICLE_FILTER_NUM_OF_PARTICLES-1));
                //TODO figure out if we want to do random or sequential.
                //go in sequential order J
                j++;
                //ensures we don't overflow
                j = j%PARTICLE_FILTER_NUM_OF_PARTICLES;
            }
        }
        //reset parameters and save overflow
        overflow = abs(p_counter);
        p_counter = uniform_distribution(50,200);

        //assign new location to the i th particle based on the current j counter.
        set_new_xyz_position(&particles[j], &particles[i]);
        // DEBUG_PRINT("j = %lu, p: %d\n", j, p_counter);
        // DEBUG_PARTICLE(&particles[i], i);
    }
    place_particles_on_new_location();
}

float low_pass_EWMA(float x_0, float y_1, float a){
    //a -> 1 minimal filtering
    //a -> 0 maximal filtering
    return a*x_0 + (1.0f-a)*y_1;

}

float high_pass_EWMA(float x_0, float x_1, float y_1, float b){

    //b-> 0 less filtering
    //b-> 1 more filtering
    return 0.5f*(2.0f-b) * (x_0-x_1) + (1.0f-b)*y_1;

    }

// float high_pass_butter_1st(float x_0, float x_1, float y_1){
//     float a = 1.001f;
//     float b = 0.999f;
//     return x_0/a + x_1/a + (b/a)*y_1;
// }
/**
 * Takes Accelerometer data and updates the motion model data.
 * This algorithm is based on the model described in the research paper (thesis)
 * 
 * How does it work: 
 * We have a single motion model particle that gets updated verry rapidly overtime usin the accelerometer data
 * once enaugh time steps have passed the new pose of this motion model particle gets transferred combined with some noise
 * to every particle. 
 * 
 * This method is less accurate but prevents us from 
 * - Having to save a lot more parameters per particle eg acceleration and velocity
 * - Reduces the computation required every acceleration time step to one particle and not N particles.
 * */
void perform_motion_model_step(MotionModelParticle* p, float sampleTimeInS){
    //update acceleration data based on last log parameter avaiable

    //TODO apply a rotation matrix to go from local reference frame to global reference frame
    //Get the logging data
    //TODO remove the sign here as well when done

    // //TODO Add calibration setup
    // p->a_x = -1* (logGetFloat(p->id_acc_x) - p->a_x_cali);
    // p->a_y = -1* (logGetFloat(p->id_acc_y) - p->a_y_cali);
    // p->a_z = -1* (logGetFloat(p->id_acc_z) - p->a_z_cali);
    
    //when using the kalman approximation
    // get the acceleration in the global reference frame
    float a_x = (logGetFloat(p->id_acc_x));
    float a_y = (logGetFloat(p->id_acc_y));
    float a_z = (logGetFloat(p->id_acc_z));

    //get the over time offset of the accelorometer
    p->a_x_f = low_pass_EWMA(a_x, p->a_x_f_, p->a);
    p->a_y_f = low_pass_EWMA(a_y, p->a_y_f_, p->a);
    p->a_z_f = low_pass_EWMA(a_z, p->a_z_f_, p->a);

    //we substract the overtime offset make alpla quite small
    p->a_x = a_x - p->a_x_f;
    p->a_y = a_y - p->a_y_f;
    p->a_z = a_z - p->a_z_f;

    //velocity update t0
    //times gravity cause the unit of acc is in Gs -> to m/s^2 = *9.81
    p->v_x = p->v_x_ + p->a_x * sampleTimeInS * 9.81f;
    p->v_y = p->v_y_ + p->a_y * sampleTimeInS * 9.81f;
    p->v_z = p->v_z_ + p->a_z * sampleTimeInS * 9.81f;

    //remove DC ofset for velocity
    p->v_x_f = high_pass_EWMA(p->v_x, p->v_x_, p->v_x_f_, p->b);
    p->v_y_f = high_pass_EWMA(p->v_y, p->v_y_, p->v_y_f_, p->b);
    p->v_z_f = high_pass_EWMA(p->v_z, p->v_z_, p->v_z_f_, p->b);

    //remove velocity drift
    if ((p->v_x > MAX_VELOCITY_BEFORE_RESET_FILTER) ||(p->v_x < -1 * MAX_VELOCITY_BEFORE_RESET_FILTER)){
        p->v_x = 0;
    }
    if ((p->v_y > MAX_VELOCITY_BEFORE_RESET_FILTER) ||(p->v_y < -1 * MAX_VELOCITY_BEFORE_RESET_FILTER)){
        p->v_y = 0;
        DEBUG_PRINT("resetting velocity estimate of motion model particle");
    }
    if ((p->v_z > MAX_VELOCITY_BEFORE_RESET_FILTER) ||(p->v_z < -1 * MAX_VELOCITY_BEFORE_RESET_FILTER)){
        p->v_z = 0;
    }

    // //remove DC ofset for velocity
    // p->v_x_f = high_pass_butter_1st(p->v_x, p->v_x_, p->v_x_f_);
    // p->v_y_f = high_pass_butter_1st(p->v_y, p->v_y_, p->v_y_f_);
    // p->v_z_f = high_pass_butter_1st(p->v_z, p->v_z_, p->v_z_f_);

    //update pose:
    p->x_curr = p->x_curr +  0.5f * (p->v_x_f + p->v_x_f_)*sampleTimeInS;
    p->y_curr = p->y_curr +  0.5f * (p->v_y_f + p->v_y_f_)*sampleTimeInS;
    p->z_curr = p->z_curr +  0.5f * (p->v_z_f + p->v_z_f_)*sampleTimeInS;

    //update acumulated distance
    p->x_abs = p->x_abs +  0.5f * (p->v_x_f + p->v_x_f_)*sampleTimeInS;
    p->y_abs = p->y_abs +  0.5f * (p->v_y_f + p->v_y_f_)*sampleTimeInS;
    p->z_abs = p->z_abs +  0.5f * (p->v_z_f + p->v_z_f_)*sampleTimeInS;

    //Update velocity t-1
    p->v_x_ = p->v_x;
    p->v_y_ = p->v_y;
    p->v_z_ = p->v_z;

    //Update filtered velocity t-1
    p->v_x_f_ = p->v_x_f;
    p->v_y_f_ = p->v_y_f;
    p->v_z_f_ = p->v_z_f;

    //Update filtered acceleration
    p->a_x_f_ = p->a_x_f;
    p->a_y_f_ = p->a_y_f;
    p->a_z_f_ = p->a_z_f;


    //update the steps taken counter
    p->motion_model_step_counter++;
}

//Sets all parameters of a motion model particle to be 0
void resetMotionModelParticleToZero(MotionModelParticle * p){
    // p->a_x = 0;
    // p->a_y = 0;
    // p->a_z = 0;
    // p->v_x = 0;
    // p->v_y = 0;
    // p->v_z = 0;
    // p->v_x_ = 0;
    // p->v_y_ = 0;
    // p->v_z_ = 0;
    p->x_curr = 0;
    p->y_curr = 0;
    p->z_curr = 0;
    p->motion_model_step_counter = 0;
}

void init_motion_model_particle(MotionModelParticle* p){
    //velocity parameters all set to 0 initially
    p->a_x = 0;
    p->a_y = 0;
    p->a_z = 0;
    p->a_x_f = 0;
    p->a_y_f = 0;
    p->a_z_f = 0;
    p->a_x_f_ = 0;
    p->a_y_f_ = 0;
    p->a_z_f_ = 0;
    p->v_x = 0;
    p->v_y = 0;
    p->v_z = 0;
    p->v_x_ = 0;
    p->v_y_ = 0;
    p->v_z_ = 0;
    p->v_x_f = 0;
    p->v_y_f = 0;
    p->v_z_f = 0;
    p->v_x_f_ = 0;
    p->v_y_f_ = 0;
    p->v_z_f_ = 0;

    //set exponential weighted highpass filter parameter:
    // p->b = 0.0015f;
    p->a = 0.001f;
    p->b = 0.0005f;


    //set the motion model particle parameters to be zero initially
    motion_model_particle.x_abs = 0;
    motion_model_particle.y_abs = 0;
    motion_model_particle.z_abs = 0;

    // ACC  log ID
    motion_model_particle.id_acc_x = logGetVarId("stateEstimate", "ax");
    motion_model_particle.id_acc_y = logGetVarId("stateEstimate", "ay");
    motion_model_particle.id_acc_z = logGetVarId("stateEstimate", "az");
    
    // motion_model_particle.id_acc_x = logGetVarId("acc", "x");
    // motion_model_particle.id_acc_y = logGetVarId("acc", "y");
    // motion_model_particle.id_acc_z = logGetVarId("acc", "z");

    motion_model_particle.syscanfly = logGetVarId("sys", "canfly");

    //count the number of measurments already taken
    motion_model_particle.EWMA_counter = 0;;
    //Do N measurements from the IMU to use in the calibration
    motion_model_particle.EWMA_number_of_calibration_measurements = 500;
    //set to true if imu is calibrated
    //! NOTE set to false if calibration is required
    //! Also diable the wire check in : canFlyCheck(); 
    motion_model_particle.calibrated = false;
    //EWMA parameter; set to small and take a lot of measurments
    motion_model_particle.alpha = 0.01f;
}

void apply_motion_model_update_to_all_particles(MotionModelParticle* mp){
    // Call by reference variables for the noise;
    float noise_x, noise_y;

    // TODO optimize the standart deviation on the particle noise;
    // Make the standart deviation number of motion model step dependent to prevent abnormally large noise on small steps
    const float std_dev = 0.01f; 

    for (uint16_t i = 0; i < PARTICLE_FILTER_NUM_OF_PARTICLES; i++){
        //obtain a normally distributed noise
        norm2(0,std_dev, &noise_x, &noise_y);
        // Update the particles pose x,y,z
            // NOTE that it can happen that the motion model is updated while we are updating the particles cause of task switch.
            // At most this can cause an irregular step in X and Y if task switch happens in between.
        particles[i].x_curr += mp->x_curr + noise_x;
        particles[i].y_curr += mp->y_curr + noise_y;
        //TODO implement the motion model for the Z particle
        particles[i].z_curr = particles[i].z_curr; 
        // DEBUG_PARTICLE(&particles[i]);

    }
    vTaskSuspendAll();
        // Set the motion model particle data to zero.
            // We don't want this to be interrupted otherways some particle steps could be much further than they really are.
        resetMotionModelParticleToZero(mp);
    xTaskResumeAll();    
}

void reset_probability_and_particle_distribution(){
    //itterate over all particles and initialize the values
    DEBUG_PRINT("Resetting: particels and probability distribution");
    for (uint32_t i = 0; i < PARTICLE_FILTER_NUM_OF_PARTICLES; i++)
        {
            set_initial_uniform_particle_distribution(&particles[i]);
            set_particle_initial_probability(&particles[i]);
        }
}

//Runs all the initialization functions of the particle filter.
void particle_filter_init(){
    //check if already inited
    if(particle_filter_inited){
        return;
    }
    //set the motion model particle parameters to be zero initially
    init_motion_model_particle(&motion_model_particle);
    resetMotionModelParticleToZero(&motion_model_particle);
    
    //init the true random number generator for the noise generation in the particle filter
    init_TRNG();

    //itterate over all particles and initialize the values
    reset_probability_and_particle_distribution();
    
    particle_filter_inited = true;
}

/**
 * This section is dedicated to run every N miliseconds to update the motion model particle.
*/
void particle_filter_tick(int tick_time_in_ms){
    //check if the particle filter has inited
    if ((!particle_filter_inited) || (!motion_model_particle.calibrated)) {
        return;
    }
    // we update a single particle based on the motion data

    perform_motion_model_step(&motion_model_particle, ((float)tick_time_in_ms)/1000.0f);
}


/* this code is split in 2 sections
1. Resampling section based on the color identification from the sensors
2. Position update based on IMU data over time.
! WARNING: to prevent Race conditions steps 1 and 2 have to be performed sequentially in the same RTOS task 
*/
void particle_filter_update(uint8_t recieved_color_ID, uint32_t sys_time_ms){
    
    //Colors 0-("NUMBER_OF_COLORS"-1) are valid colors , "NUMBER_OF_COLORS" is invalid color
    static uint8_t last_recieved_color_ID = NUMBER_OF_COLORS;

    //Timing parameters static initialized to 0 keep track on when a new particle update needs to happen
    static uint32_t time_since_last_resample = 0;
    static uint32_t boot_delay = 0;

    
    //check if the particle filter has inited and a calibration has happend (in case required)
    if ((!particle_filter_inited) || (!motion_model_particle.calibrated)){
        //this is here to not overload the drone systems on startup
        // yes this was a fun bug to figure out....
        time_since_last_resample = sys_time_ms;
        boot_delay = sys_time_ms;

        return;
    }

    // Resampling happens when:
    //      (New Color data is recieved.   OR   A set time interval has passed).
    //              AND    recieved_color_ID != NUMBER_OF_COLORS
    if(
        ((last_recieved_color_ID != recieved_color_ID)
            ||((time_since_last_resample + UPDATE_TIME_INTERVAL_PARTICLE_RESAMPLE) < sys_time_ms))
        &&(recieved_color_ID != NUMBER_OF_COLORS)
    ){
        //perform the resample sequence
        determine_expected_color_for_all_particles();
        uint16_t particles_with_wrong_color_count =  set_particle_probability(last_recieved_color_ID);

        //if all particles have the wrong collor scatter the particles to a uniform distibution
        // if not then perform a normal resample procedure
        if (particles_with_wrong_color_count < PARTICLE_FILTER_NUM_OF_PARTICLES){
            resample_particles();
        }else{
            reset_probability_and_particle_distribution();
        }

        //update conditional parameters
        time_since_last_resample = sys_time_ms;
        last_recieved_color_ID = recieved_color_ID;
        DEBUG_PRINT("performing resample to ID: %d", recieved_color_ID);
    }

    /**
     * After N Motion model steps we would like to update all particles.
    */
    if((motion_model_particle.motion_model_step_counter > UPDATE_ALL_PARTICLES_AFTER_MOTION_MODEL_STEPS)
     && ((boot_delay + 8000) < sys_time_ms)) {
        // DEBUG_MOTION_PARTICLE(&motion_model_particle);
        apply_motion_model_update_to_all_particles(&motion_model_particle);
    }

    //sync the locations such that the visualisation interface can be updated
    sync_int16_particle_locations();
    
}


LOG_GROUP_START(CStateEstimate)
                LOG_ADD_CORE(LOG_FLOAT, ax, &motion_model_particle.a_x)
                LOG_ADD_CORE(LOG_FLOAT, ay, &motion_model_particle.a_y)
                LOG_ADD_CORE(LOG_FLOAT, az, &motion_model_particle.a_z)

                LOG_ADD_CORE(LOG_FLOAT, vx, &motion_model_particle.v_x)
                LOG_ADD_CORE(LOG_FLOAT, vy, &motion_model_particle.v_y)
                LOG_ADD_CORE(LOG_FLOAT, vz, &motion_model_particle.v_z)
                
                LOG_ADD_CORE(LOG_FLOAT, vx_f, &motion_model_particle.v_x_f)
                LOG_ADD_CORE(LOG_FLOAT, vy_f, &motion_model_particle.v_y_f)
                LOG_ADD_CORE(LOG_FLOAT, vz_f, &motion_model_particle.v_z_f)

                LOG_ADD_CORE(LOG_FLOAT, x, &motion_model_particle.x_curr)
                LOG_ADD_CORE(LOG_FLOAT, y, &motion_model_particle.y_curr)
                LOG_ADD_CORE(LOG_FLOAT, z, &motion_model_particle.z_curr)

                LOG_ADD_CORE(LOG_FLOAT, absx, &motion_model_particle.x_abs)
                LOG_ADD_CORE(LOG_FLOAT, absy, &motion_model_particle.y_abs)
                LOG_ADD_CORE(LOG_FLOAT, absz, &motion_model_particle.z_abs)

                LOG_ADD_CORE(LOG_FLOAT, a_x_cali, &motion_model_particle.a_x_cali)
                LOG_ADD_CORE(LOG_FLOAT, a_y_cali, &motion_model_particle.a_y_cali)
                LOG_ADD_CORE(LOG_FLOAT, a_z_cali, &motion_model_particle.a_z_cali)

                LOG_ADD_CORE(LOG_FLOAT, x_mean, &motion_model_particle.x_mean)
                LOG_ADD_CORE(LOG_FLOAT, y_mean, &motion_model_particle.y_mean)
                LOG_ADD_CORE(LOG_FLOAT, z_mean, &motion_model_particle.z_mean)

LOG_GROUP_STOP(CStateEstimate)

LOG_GROUP_START(ParticleFilter)
                LOG_ADD_CORE(LOG_INT16, x0_16, &particles[0].x_curr_16)
                LOG_ADD_CORE(LOG_INT16, y0_16, &particles[0].y_curr_16)
                LOG_ADD_CORE(LOG_INT16, x1_16, &particles[1].x_curr_16)
                LOG_ADD_CORE(LOG_INT16, y1_16, &particles[1].y_curr_16)
                LOG_ADD_CORE(LOG_INT16, x2_16, &particles[2].x_curr_16)
                LOG_ADD_CORE(LOG_INT16, y2_16, &particles[2].y_curr_16)
                LOG_ADD_CORE(LOG_INT16, x3_16, &particles[3].x_curr_16)
                LOG_ADD_CORE(LOG_INT16, y3_16, &particles[3].y_curr_16)
                LOG_ADD_CORE(LOG_INT16, x4_16, &particles[4].x_curr_16)
                LOG_ADD_CORE(LOG_INT16, y4_16, &particles[4].y_curr_16)
                LOG_ADD_CORE(LOG_INT16, x5_16, &particles[5].x_curr_16)
                LOG_ADD_CORE(LOG_INT16, y5_16, &particles[5].y_curr_16)
                LOG_ADD_CORE(LOG_INT16, x6_16, &particles[6].x_curr_16)
                LOG_ADD_CORE(LOG_INT16, y6_16, &particles[6].y_curr_16)
                LOG_ADD_CORE(LOG_INT16, x7_16, &particles[7].x_curr_16)
                LOG_ADD_CORE(LOG_INT16, y7_16, &particles[7].y_curr_16)
                LOG_ADD_CORE(LOG_INT16, x8_16, &particles[8].x_curr_16)
                LOG_ADD_CORE(LOG_INT16, y8_16, &particles[8].y_curr_16)
                LOG_ADD_CORE(LOG_INT16, x9_16, &particles[9].x_curr_16)
                LOG_ADD_CORE(LOG_INT16, y9_16, &particles[9].y_curr_16)
                LOG_ADD_CORE(LOG_INT16, x10_16, &particles[10].x_curr_16)
                LOG_ADD_CORE(LOG_INT16, y10_16, &particles[10].y_curr_16)
                LOG_ADD_CORE(LOG_INT16, x11_16, &particles[11].x_curr_16)
                LOG_ADD_CORE(LOG_INT16, y11_16, &particles[11].y_curr_16)
                LOG_ADD_CORE(LOG_INT16, x12_16, &particles[12].x_curr_16)
                LOG_ADD_CORE(LOG_INT16, y12_16, &particles[12].y_curr_16)
                LOG_ADD_CORE(LOG_INT16, x13_16, &particles[13].x_curr_16)
                LOG_ADD_CORE(LOG_INT16, y13_16, &particles[13].y_curr_16)
                LOG_ADD_CORE(LOG_INT16, x14_16, &particles[14].x_curr_16)
                LOG_ADD_CORE(LOG_INT16, y14_16, &particles[14].y_curr_16)
                LOG_ADD_CORE(LOG_INT16, x15_16, &particles[15].x_curr_16)
                LOG_ADD_CORE(LOG_INT16, y15_16, &particles[15].y_curr_16)
                LOG_ADD_CORE(LOG_INT16, x16_16, &particles[16].x_curr_16)
                LOG_ADD_CORE(LOG_INT16, y16_16, &particles[16].y_curr_16)
                LOG_ADD_CORE(LOG_INT16, x17_16, &particles[17].x_curr_16)
                LOG_ADD_CORE(LOG_INT16, y17_16, &particles[17].y_curr_16)
                LOG_ADD_CORE(LOG_INT16, x18_16, &particles[18].x_curr_16)
                LOG_ADD_CORE(LOG_INT16, y18_16, &particles[18].y_curr_16)
                LOG_ADD_CORE(LOG_INT16, x19_16, &particles[19].x_curr_16)
                LOG_ADD_CORE(LOG_INT16, y19_16, &particles[19].y_curr_16)
                LOG_ADD_CORE(LOG_INT16, x20_16, &particles[20].x_curr_16)
                LOG_ADD_CORE(LOG_INT16, y20_16, &particles[20].y_curr_16)
                LOG_ADD_CORE(LOG_INT16, x21_16, &particles[21].x_curr_16)
                LOG_ADD_CORE(LOG_INT16, y21_16, &particles[21].y_curr_16)
                LOG_ADD_CORE(LOG_INT16, x22_16, &particles[22].x_curr_16)
                LOG_ADD_CORE(LOG_INT16, y22_16, &particles[22].y_curr_16)
                LOG_ADD_CORE(LOG_INT16, x23_16, &particles[23].x_curr_16)
                LOG_ADD_CORE(LOG_INT16, y23_16, &particles[23].y_curr_16)
                LOG_ADD_CORE(LOG_INT16, x24_16, &particles[24].x_curr_16)
                LOG_ADD_CORE(LOG_INT16, y24_16, &particles[24].y_curr_16)
                LOG_ADD_CORE(LOG_INT16, x25_16, &particles[25].x_curr_16)
                LOG_ADD_CORE(LOG_INT16, y25_16, &particles[25].y_curr_16)
                LOG_ADD_CORE(LOG_INT16, x26_16, &particles[26].x_curr_16)
                LOG_ADD_CORE(LOG_INT16, y26_16, &particles[26].y_curr_16)
                LOG_ADD_CORE(LOG_INT16, x27_16, &particles[27].x_curr_16)
                LOG_ADD_CORE(LOG_INT16, y27_16, &particles[27].y_curr_16)
                LOG_ADD_CORE(LOG_INT16, x28_16, &particles[28].x_curr_16)
                LOG_ADD_CORE(LOG_INT16, y28_16, &particles[28].y_curr_16)
                LOG_ADD_CORE(LOG_INT16, x29_16, &particles[29].x_curr_16)
                LOG_ADD_CORE(LOG_INT16, y29_16, &particles[29].y_curr_16)
                LOG_ADD_CORE(LOG_INT16, x30_16, &particles[30].x_curr_16)
                LOG_ADD_CORE(LOG_INT16, y30_16, &particles[30].y_curr_16)
                LOG_ADD_CORE(LOG_INT16, x31_16, &particles[31].x_curr_16)
                LOG_ADD_CORE(LOG_INT16, y31_16, &particles[31].y_curr_16)
                LOG_ADD_CORE(LOG_INT16, x32_16, &particles[32].x_curr_16)
                LOG_ADD_CORE(LOG_INT16, y32_16, &particles[32].y_curr_16)
                LOG_ADD_CORE(LOG_INT16, x33_16, &particles[33].x_curr_16)
                LOG_ADD_CORE(LOG_INT16, y33_16, &particles[33].y_curr_16)
                LOG_ADD_CORE(LOG_INT16, x34_16, &particles[34].x_curr_16)
                LOG_ADD_CORE(LOG_INT16, y34_16, &particles[34].y_curr_16)
                LOG_ADD_CORE(LOG_INT16, x35_16, &particles[35].x_curr_16)
                LOG_ADD_CORE(LOG_INT16, y35_16, &particles[35].y_curr_16)
                LOG_ADD_CORE(LOG_INT16, x36_16, &particles[36].x_curr_16)
                LOG_ADD_CORE(LOG_INT16, y36_16, &particles[36].y_curr_16)
                LOG_ADD_CORE(LOG_INT16, x37_16, &particles[37].x_curr_16)
                LOG_ADD_CORE(LOG_INT16, y37_16, &particles[37].y_curr_16)
                LOG_ADD_CORE(LOG_INT16, x38_16, &particles[38].x_curr_16)
                LOG_ADD_CORE(LOG_INT16, y38_16, &particles[38].y_curr_16)
                LOG_ADD_CORE(LOG_INT16, x39_16, &particles[39].x_curr_16)
                LOG_ADD_CORE(LOG_INT16, y39_16, &particles[39].y_curr_16)
                LOG_ADD_CORE(LOG_INT16, x40_16, &particles[40].x_curr_16)
                LOG_ADD_CORE(LOG_INT16, y40_16, &particles[40].y_curr_16)
                LOG_ADD_CORE(LOG_INT16, x41_16, &particles[41].x_curr_16)
                LOG_ADD_CORE(LOG_INT16, y41_16, &particles[41].y_curr_16)
                LOG_ADD_CORE(LOG_INT16, x42_16, &particles[42].x_curr_16)
                LOG_ADD_CORE(LOG_INT16, y42_16, &particles[42].y_curr_16)
                LOG_ADD_CORE(LOG_INT16, x43_16, &particles[43].x_curr_16)
                LOG_ADD_CORE(LOG_INT16, y43_16, &particles[43].y_curr_16)
                LOG_ADD_CORE(LOG_INT16, x44_16, &particles[44].x_curr_16)
                LOG_ADD_CORE(LOG_INT16, y44_16, &particles[44].y_curr_16)
                LOG_ADD_CORE(LOG_INT16, x45_16, &particles[45].x_curr_16)
                LOG_ADD_CORE(LOG_INT16, y45_16, &particles[45].y_curr_16)
                LOG_ADD_CORE(LOG_INT16, x46_16, &particles[46].x_curr_16)
                LOG_ADD_CORE(LOG_INT16, y46_16, &particles[46].y_curr_16)
                LOG_ADD_CORE(LOG_INT16, x47_16, &particles[47].x_curr_16)
                LOG_ADD_CORE(LOG_INT16, y47_16, &particles[47].y_curr_16)
                LOG_ADD_CORE(LOG_INT16, x48_16, &particles[48].x_curr_16)
                LOG_ADD_CORE(LOG_INT16, y48_16, &particles[48].y_curr_16)
                LOG_ADD_CORE(LOG_INT16, x49_16, &particles[49].x_curr_16)
                LOG_ADD_CORE(LOG_INT16, y49_16, &particles[49].y_curr_16)
                LOG_ADD_CORE(LOG_INT16, x50_16, &particles[50].x_curr_16)
                LOG_ADD_CORE(LOG_INT16, y50_16, &particles[50].y_curr_16)
                LOG_ADD_CORE(LOG_INT16, x51_16, &particles[51].x_curr_16)
                LOG_ADD_CORE(LOG_INT16, y51_16, &particles[51].y_curr_16)
                LOG_ADD_CORE(LOG_INT16, x52_16, &particles[52].x_curr_16)
                LOG_ADD_CORE(LOG_INT16, y52_16, &particles[52].y_curr_16)
                LOG_ADD_CORE(LOG_INT16, x53_16, &particles[53].x_curr_16)
                LOG_ADD_CORE(LOG_INT16, y53_16, &particles[53].y_curr_16)
                LOG_ADD_CORE(LOG_INT16, x54_16, &particles[54].x_curr_16)
                LOG_ADD_CORE(LOG_INT16, y54_16, &particles[54].y_curr_16)
                LOG_ADD_CORE(LOG_INT16, x55_16, &particles[55].x_curr_16)
                LOG_ADD_CORE(LOG_INT16, y55_16, &particles[55].y_curr_16)
                LOG_ADD_CORE(LOG_INT16, x56_16, &particles[56].x_curr_16)
                LOG_ADD_CORE(LOG_INT16, y56_16, &particles[56].y_curr_16)
                LOG_ADD_CORE(LOG_INT16, x57_16, &particles[57].x_curr_16)
                LOG_ADD_CORE(LOG_INT16, y57_16, &particles[57].y_curr_16)
                LOG_ADD_CORE(LOG_INT16, x58_16, &particles[58].x_curr_16)
                LOG_ADD_CORE(LOG_INT16, y58_16, &particles[58].y_curr_16)
                LOG_ADD_CORE(LOG_INT16, x59_16, &particles[59].x_curr_16)
                LOG_ADD_CORE(LOG_INT16, y59_16, &particles[59].y_curr_16)
                LOG_ADD_CORE(LOG_INT16, x60_16, &particles[60].x_curr_16)
                LOG_ADD_CORE(LOG_INT16, y60_16, &particles[60].y_curr_16)
                LOG_ADD_CORE(LOG_INT16, x61_16, &particles[61].x_curr_16)
                LOG_ADD_CORE(LOG_INT16, y61_16, &particles[61].y_curr_16)
                LOG_ADD_CORE(LOG_INT16, x62_16, &particles[62].x_curr_16)
                LOG_ADD_CORE(LOG_INT16, y62_16, &particles[62].y_curr_16)
                LOG_ADD_CORE(LOG_INT16, x63_16, &particles[63].x_curr_16)
                LOG_ADD_CORE(LOG_INT16, y63_16, &particles[63].y_curr_16)
                LOG_ADD_CORE(LOG_INT16, x64_16, &particles[64].x_curr_16)
                LOG_ADD_CORE(LOG_INT16, y64_16, &particles[64].y_curr_16)
                LOG_ADD_CORE(LOG_INT16, x65_16, &particles[65].x_curr_16)
                LOG_ADD_CORE(LOG_INT16, y65_16, &particles[65].y_curr_16)
                LOG_ADD_CORE(LOG_INT16, x66_16, &particles[66].x_curr_16)
                LOG_ADD_CORE(LOG_INT16, y66_16, &particles[66].y_curr_16)
                LOG_ADD_CORE(LOG_INT16, x67_16, &particles[67].x_curr_16)
                LOG_ADD_CORE(LOG_INT16, y67_16, &particles[67].y_curr_16)
                LOG_ADD_CORE(LOG_INT16, x68_16, &particles[68].x_curr_16)
                LOG_ADD_CORE(LOG_INT16, y68_16, &particles[68].y_curr_16)
                LOG_ADD_CORE(LOG_INT16, x69_16, &particles[69].x_curr_16)
                LOG_ADD_CORE(LOG_INT16, y69_16, &particles[69].y_curr_16)
                LOG_ADD_CORE(LOG_INT16, x70_16, &particles[70].x_curr_16)
                LOG_ADD_CORE(LOG_INT16, y70_16, &particles[70].y_curr_16)
                LOG_ADD_CORE(LOG_INT16, x71_16, &particles[71].x_curr_16)
                LOG_ADD_CORE(LOG_INT16, y71_16, &particles[71].y_curr_16)
                LOG_ADD_CORE(LOG_INT16, x72_16, &particles[72].x_curr_16)
                LOG_ADD_CORE(LOG_INT16, y72_16, &particles[72].y_curr_16)
                LOG_ADD_CORE(LOG_INT16, x73_16, &particles[73].x_curr_16)
                LOG_ADD_CORE(LOG_INT16, y73_16, &particles[73].y_curr_16)
                LOG_ADD_CORE(LOG_INT16, x74_16, &particles[74].x_curr_16)
                LOG_ADD_CORE(LOG_INT16, y74_16, &particles[74].y_curr_16)
                LOG_ADD_CORE(LOG_INT16, x75_16, &particles[75].x_curr_16)
                LOG_ADD_CORE(LOG_INT16, y75_16, &particles[75].y_curr_16)
                LOG_ADD_CORE(LOG_INT16, x76_16, &particles[76].x_curr_16)
                LOG_ADD_CORE(LOG_INT16, y76_16, &particles[76].y_curr_16)
                LOG_ADD_CORE(LOG_INT16, x77_16, &particles[77].x_curr_16)
                LOG_ADD_CORE(LOG_INT16, y77_16, &particles[77].y_curr_16)
                LOG_ADD_CORE(LOG_INT16, x78_16, &particles[78].x_curr_16)
                LOG_ADD_CORE(LOG_INT16, y78_16, &particles[78].y_curr_16)
                LOG_ADD_CORE(LOG_INT16, x79_16, &particles[79].x_curr_16)
                LOG_ADD_CORE(LOG_INT16, y79_16, &particles[79].y_curr_16)
                LOG_ADD_CORE(LOG_INT16, x80_16, &particles[80].x_curr_16)
                LOG_ADD_CORE(LOG_INT16, y80_16, &particles[80].y_curr_16)
                LOG_ADD_CORE(LOG_INT16, x81_16, &particles[81].x_curr_16)
                LOG_ADD_CORE(LOG_INT16, y81_16, &particles[81].y_curr_16)
                LOG_ADD_CORE(LOG_INT16, x82_16, &particles[82].x_curr_16)
                LOG_ADD_CORE(LOG_INT16, y82_16, &particles[82].y_curr_16)
                LOG_ADD_CORE(LOG_INT16, x83_16, &particles[83].x_curr_16)
                LOG_ADD_CORE(LOG_INT16, y83_16, &particles[83].y_curr_16)
                LOG_ADD_CORE(LOG_INT16, x84_16, &particles[84].x_curr_16)
                LOG_ADD_CORE(LOG_INT16, y84_16, &particles[84].y_curr_16)
                LOG_ADD_CORE(LOG_INT16, x85_16, &particles[85].x_curr_16)
                LOG_ADD_CORE(LOG_INT16, y85_16, &particles[85].y_curr_16)
                LOG_ADD_CORE(LOG_INT16, x86_16, &particles[86].x_curr_16)
                LOG_ADD_CORE(LOG_INT16, y86_16, &particles[86].y_curr_16)
                LOG_ADD_CORE(LOG_INT16, x87_16, &particles[87].x_curr_16)
                LOG_ADD_CORE(LOG_INT16, y87_16, &particles[87].y_curr_16)
                LOG_ADD_CORE(LOG_INT16, x88_16, &particles[88].x_curr_16)
                LOG_ADD_CORE(LOG_INT16, y88_16, &particles[88].y_curr_16)
                LOG_ADD_CORE(LOG_INT16, x89_16, &particles[89].x_curr_16)
                LOG_ADD_CORE(LOG_INT16, y89_16, &particles[89].y_curr_16)
                LOG_ADD_CORE(LOG_INT16, x90_16, &particles[90].x_curr_16)
                LOG_ADD_CORE(LOG_INT16, y90_16, &particles[90].y_curr_16)
                LOG_ADD_CORE(LOG_INT16, x91_16, &particles[91].x_curr_16)
                LOG_ADD_CORE(LOG_INT16, y91_16, &particles[91].y_curr_16)
                LOG_ADD_CORE(LOG_INT16, x92_16, &particles[92].x_curr_16)
                LOG_ADD_CORE(LOG_INT16, y92_16, &particles[92].y_curr_16)
                LOG_ADD_CORE(LOG_INT16, x93_16, &particles[93].x_curr_16)
                LOG_ADD_CORE(LOG_INT16, y93_16, &particles[93].y_curr_16)
                LOG_ADD_CORE(LOG_INT16, x94_16, &particles[94].x_curr_16)
                LOG_ADD_CORE(LOG_INT16, y94_16, &particles[94].y_curr_16)
                LOG_ADD_CORE(LOG_INT16, x95_16, &particles[95].x_curr_16)
                LOG_ADD_CORE(LOG_INT16, y95_16, &particles[95].y_curr_16)
                LOG_ADD_CORE(LOG_INT16, x96_16, &particles[96].x_curr_16)
                LOG_ADD_CORE(LOG_INT16, y96_16, &particles[96].y_curr_16)
                LOG_ADD_CORE(LOG_INT16, x97_16, &particles[97].x_curr_16)
                LOG_ADD_CORE(LOG_INT16, y97_16, &particles[97].y_curr_16)
                LOG_ADD_CORE(LOG_INT16, x98_16, &particles[98].x_curr_16)
                LOG_ADD_CORE(LOG_INT16, y98_16, &particles[98].y_curr_16)
                LOG_ADD_CORE(LOG_INT16, x99_16, &particles[99].x_curr_16)
                LOG_ADD_CORE(LOG_INT16, y99_16, &particles[99].y_curr_16)

LOG_GROUP_STOP(ParticleFilter)